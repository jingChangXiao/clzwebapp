/**
* @file 文件说明
* @author xjc
* @date
*/
<template>
  <div style="overflow-y: scroll;height: 100%;">
    <el-table
      :data="tableData"
      :span-method="objectSpanMethod"
      border
      @cell-click="handleGrid"
      style="width: 100%;">
      <el-table-column v-for="(item, index) in tableHeaders" :min-width="item.width" :label="item.name" :key="index">
        <template slot-scope="scope">
          <span :style="isMerge ? scope.row[index]['style'] : {}">{{isMerge ? scope.row[index][tableHeaders[index].prop] : scope.row[tableHeaders[index].prop]}}</span>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script>
  let dataTitle = []
  let dataO = []
  let cacheData = []// 记录合计项，给element的
  // let mergeData = []// 记录合计项的数据
  export default {
    name: 'excelTable',
    props: {
      dataO: {
        type: Array,
        default: function () {
          return []
        }
      },
      dataTitle: {
        type: Array,
        default: function () {
          return []
        }
      },
      mergeIndex: {
        type: Number | String,
        default: 0
      }
    },
    data () {
      return {
        isMerge: true,
        tableData: [],
        tableHeaders: []
      }
    },
    mounted () {
      dataO = this.dataO
      dataTitle = this.dataTitle
      let arr = []
      dataTitle.forEach((item) => {
        item.prop = item.id
        arr.push(Object.assign({}, item))
      })
      this.tableHeaders = arr
      if (!dataO || dataO.length === 0) return
      this.isMerge = Object.prototype.toString.call(dataO[0]) === '[object Array]'
      this.isMerge ? this.excelDataInit() : this.normalData()
    },
    methods: {
      objectSpanMethod ({row, column, rowIndex, columnIndex}) {
        if (this.isMerge) {
          let colNum = cacheData[rowIndex][columnIndex]
          if (colNum < 2) {
            return {
              rowspan: colNum,
              colspan: colNum
            }
          } else {
            return {
              rowspan: colNum,
              colspan: 1
            }
          }
        }
      },
      handleGrid (row, column, cell, event) {
        this.$emit('handleGrid', row, column, cell, event)
      },
      normalData () {
        this.tableData = dataO
      },
      excelDataInit () {
        this.firstStep()
        this.secondStep()
        this.tableData = dataO
      },
      firstStep () {
        // 记录操作次数
        let handelNum = 0
        let n = this.mergeIndex // 有几列要计算合并
        let self = this
        dataO.forEach((q, index) => { // q对应表格的行数据，index对应当前是哪一行
          let t = dataO[index + handelNum]// 当前遍历到的行
          let t1 = dataO[(index + 1) + handelNum] || t
          t.forEach((obj) => {
            if (!('id' in obj)) { // 如果咩有id就默认给一个
              obj.id = index
            }
            if (!('style' in obj)) { // 如果咩有id就默认给一个
              obj.style = {}
            }
          })
          // 判断要合并的这个列，是不是id改变了，但是，这样判断的话，最后剩下的那几排就找不到了，所以加上后面的或条件
          if (t[n - 1].id !== t1[n - 1].id || !dataO[(index + 1) + handelNum]) {
            let mark = index + handelNum// 记录遍历到第几条数据了
            // debugger
            let arr = []
            t.forEach((grid, d) => {
              // grid对应表格的格子，d对应当前列数
              // debugger
              if (d < n) {
                arr.push(Object.assign({}, grid))
              } else if (d === n) {
                let obj = Object.assign({}, grid)
                let hearderObj = this.tableHeaders[d]
                obj[hearderObj.prop] = hearderObj.name + '小计'
                obj.id += '' + index // 让id和上一个不同，不然会合并的
                arr.push(obj)
              } else {
                // 开始计算合计
                let result = 0
                let m = mark
                // debugger
                for (; m > -1; m--) {
                  if (t[n - 1].id !== dataO[m][n - 1].id) break// 如果遇到id不一致的就停下
                  result += dataO[m][d][self.tableHeaders[d].prop]
                }
                let obj = Object.assign({}, grid)
                obj[this.tableHeaders[d].prop] = result
                obj.id += '' + index
                arr.push(obj)
              }
            })
            handelNum++
            dataO.splice(index + handelNum, 0, arr)
            // mergeData.push(arr)
          }
        })
        console.log(dataO)
        // console.log(mergeData)
      },
      secondStep () {
        // 记录上一条数据的id
        let cacheId = []
        // 记录合并项的位置
        let cacheIndex = []
        dataO.forEach((t, index) => {
          cacheData[index] = []
          Array.isArray(t) && t.forEach((item, i) => {
            if (index === 0) {
              cacheData[0][i] = 1
              cacheId[i] = item.id
              cacheIndex[i] = 0
            } else {
              if (item.id === cacheId[i]) {
                cacheData[cacheIndex[i]][i]++
                cacheData[index][i] = 0
              } else {
                cacheIndex[i] = index
                cacheData[index][i] = 1
                cacheId[i] = item.id
              }
            }
          })
        })
        console.log(cacheData)
      }
    }
  }
</script>

<style lang="less" rel="stylesheet/less" scoped>
  td {
    vertical-align: middle;
    text-align: center;
  }
</style>
